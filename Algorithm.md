# 연속 행렬 곱셈 [팀 과제]

# 1. 연속 행렬 곱셈

연속 행렬 곱셈이란 연속된 행렬들의 곱셈에 필요한 행렬의 곱셈 순서를 찾는 알고리즘이다.     
행렬의 곱셈은 (A * B)*C = A*(B * C)와 같이 결합법칩이 성립한다.        
또한, 행렬을 곱하는 순서에 따라 곱하는 횟수가 달라진다.       

![algo20-2](https://user-images.githubusercontent.com/101388345/163195312-462f1c09-ef49-4487-a049-2d355a8b6add.png)               
예를 들어 위와 같이 세 개의 행렬을 곱하는 경우 위에서 언급한 결합법칙이 적용한다.        
A*B를 계산 후 C를 곱하는 경우 A * B = 10 * 20 *5 = 1000, AB * C = 10 * 5 * 15 = 750이 된다.     
따라서 1000 + 750 = 1750이 된다.       
B*C를 계산 후 A를 곱하는 경우 B * C = 20 * 15 * 5 = 1500, A * BC = 10 * 20 * 15 = 3000이 된다.     
따라서 1500 + 3000 = 4500이 된다.        
동일한 행렬을 순서만 바꿔서 곱했을 뿐인데 곱셈 횟수의 차이가 나는 것을 알 수 있다.      
따라서 곱셈 횟수를 최소화하기 위해서 행렬의 곱셈 순서를 구하는 것이 연속 행렬 곱셈 알고리즘이라고 할 수 있다.      

만약 A1(d0xd1), A2(d1xd2), A3(d2xd3), A4(d3xd5), A5(d4xd5), … 이라는 행렬이 있다고 해보자.       
따라서 행렬 An은 dn-1행의 dn열이라고 할 수 있다.   
행렬의 곱 An * An+1을 C라고 하면, ![image](https://user-images.githubusercontent.com/101388345/163203480-70f8e749-2ff0-4b6f-8226-4315a06c6666.png) 
을 사용해서 행렬의 곱에 필요한 연산 횟수는 dn-1 * dn * dn+1이 된다.           


![image](https://user-images.githubusercontent.com/101388345/163203897-dce282ad-eb04-412f-81cc-da6e072aebb7.png)도식화 한 그림        



연속 행렬 곱셈 알고리즘은 동적계획 알고리즘을 이용하는 알고리즘이다.           
동적계획 알고리즘이란 어떤 문제를 풀기 위해 간단한 여러 문제로 나누어서 푼 후, 구한 해를 활용해 원래 문제를 푸는 방식이다.          

위의 예시의 행렬을 동적계획 알고리즘을 사용해 풀이하려면 3가지 단계를 거친다.        
1) Optimal substructure(최적 부분구조) 찾기     
Optimal substructure이란 주어진 문제를 해결할 수 있는 작은 문제의 최적의 솔루션을 말한다.      
이 행렬에서 Optimal substructure은 전체 행렬을 나누는 것이다.     
행렬의 개수가 j만큼 있고, k번째에서 행렬의 집합을 나눈다. (i ≤ k ≤ j)       
Ai……Aj 행렬을 (Ai…Ak)(Ak+1…Aj)로 분할 하는 것이다.          

2) A Rescursive Solution (재귀 관계식 찾기)       
위에서 나눠진 행렬에서 재귀적으로 수행시키기 위해 관계식을 찾는다.        
i번째 행렬부터 j까지의 행렬을 곱할 때 필요한 곱셈 연산 횟수를 m[i,j]라 한다.           
행렬의 최소 곱셈 재귀 관계식은 아래와 같다.     
![2522304C5925997205](https://user-images.githubusercontent.com/101388345/163214208-ab1cfb08-31fa-407b-83fc-de8b30efcef8.png)        

여기서 M[i][k] + M[k+1][j]는 최소연산횟수를 구해서 더하는 것이고, di-1dkdj는 발생하는 총 연산 횟수이다.         
따라서 전체 행렬에 대한 최소 연산 횟수를 구할 수 있다.        

3) Computing the optimal costs           
A2 * A3 * A4 *  A5의 연산 횟수가 최초가 되는 순서를 결정한다.           
k = 2이면 A2 * (A3 * A4 * A5) 이고 재귀관계식으로 계산하면 min[2,5] = min(m[2,2]+m[3,5]+d₁d₂d₅) = 0 + m[3,5] + d₁d₂d₅)이다.     
k = 3이면 (A2 * A3) * (A4 * A5)이고 재귀관계식으로 계산하면 min[2,5] = min(m[2,3]+m[4,5]+d₁d₃d₅)이다.        
k = 4이면 (A2 * A3 * A4) * A5이고 재귀관계식으로 계산하면 min[2,5] = min(m[2,4]+m[5,5]+d₁d₄d₅)이다.        

![image](https://user-images.githubusercontent.com/101388345/163226590-a69ab95e-ed80-4ff9-9622-ea9510e58995.png)         

따라서 위와 같이 대각선을 하나씩 증가시키며 곱셈의 최소 횟수를 구한다.        
칸을 채우는 데 가장 오래 걸리는 것은 오른쪽 제일 위 칸이다.         
시간 복잡도는 총 부분 문제 수 가 (n-1) + (n-2) + ... +2 + 1으로 n(n-1)/2이고 for 문에서 i가 최대 n번 수행 하므로      
O(n^2) * O(n) = O(n^3)이 된다.            


# 2. 의사 코드        

위의 개념을 바탕으로 의사 코드를 만들어 보았다.          


![image](https://user-images.githubusercontent.com/101388345/163220347-872ab656-d2e0-4bc0-a337-ee69fec20092.png)          

![image](https://user-images.githubusercontent.com/101388345/163215625-92cf524a-46f9-4f9f-b6c5-017805a5b895.png)              



# 3. 알고리즘 구현      

의사 코드를 반복문으로 구현했음으로, 알고리즘 또한 반복문으로 구현해 보았다.        

![image](https://user-images.githubusercontent.com/101388345/163216550-bfc9eb0f-09f9-4e18-8bc5-abce539642b8.png)              


1) 행렬의 개수와 행렬의 크기를 입력할 수 있는 배열을 선언한다.(dp는 위에서 언급한 동적계획 알고리즘이다.)         
2) Scanner 함수를 이용해 입력을 받는다.           
3) arr[N][2]는 입력받는 행렬이고, dp[N][N]은 I번째 행렬부터 j번째 행렬까지 곱한 횟수이다. ( 0 ≤ i < j < N)         
    
![image](https://user-images.githubusercontent.com/101388345/163217757-54fa9006-0a6e-4131-8c56-2d650b68c009.png)        


위의 그림을 통해 for문을 구현해 보면, A(a,?) / B(? b) / B+1(b,?) / C(?,c)라고 할 때 A에서 B까지 곱하면 a * b행렬이 나오고,     
B+1에서 C까지 곱하면 b * c의 행렬이 나온다.         
?은 dp[a][b]+dp[b+1][c]+ arr[a][0] * arr[b][1] * arr[c][1]이다.           
이것은 a에서 b까지의 비용과 b+1에서 c까지의 비용에 arr[a][0] * arr[b][1] * arr[c][1]를 더한 것이다.          

이를 for문으로 구현하면        
![image](https://user-images.githubusercontent.com/101388345/163220031-3a3f580d-160e-4351-8696-b25a68fc3340.png)          

첫 번째 for문은 시작점부터 끝점까지의 거리를 나타낸다.           
두 번째 for문은 시작점을 나타낸다.               
세 번째 for문은 시작점부터 중간지점까지의 거리를 나타낸다.              


# 4. 예제를 사용한 알고리즘 확인           

![image](https://user-images.githubusercontent.com/101388345/163220612-7100b2c5-6823-4e1a-8e1c-fdbb9a50c26e.png)           

알고리즘의 확인을 위해 위와 같은 행렬이 있다고 하자.               
위와 같은 행렬은 두가지 방식으로 구할 수 있다.           

![image](https://user-images.githubusercontent.com/101388345/163220763-cbb7304c-0733-49a1-bdf7-9478c4350e9b.png)            

1) A * B를 먼저 계산한 후에 그 결과 행렬과 행렬 C를 곱하는 경우다.             
A * B=20 * 30 * 50 = 30000 , AB*C = 20*50*40 = 40000이다.       
따라서 총 30000 + 40000 = 70000회의 원소의 곱셈이 필요하다.          


![image](https://user-images.githubusercontent.com/101388345/163221099-96a123eb-3eb8-4d4d-b545-35bfac1d6495.png)                 
2) B * C를 먼저 계산한 후에 그 결과 행렬과 행렬 A를 곱하는 경우이다.              
B * C = 30 * 50 * 40 = 60000이고 A * BC = 20 * 30 * 40 = 24000이다.             
따라서 총 60000 + 24000 = 84000회의 원소의 곱셈이 필요하다.              

이것을 위의 구현한 알고리즘에 넣어 결과를 확인해 봤다.          

![image](https://user-images.githubusercontent.com/101388345/163221445-a50decd9-4963-4f1a-a755-1100272addad.png)               

위의 결과처럼 1)의 경우인 70000회의 결과값이 나오면서 알고리즘이 제대로 작동하고 있다는 것을 알 수 있다.         
